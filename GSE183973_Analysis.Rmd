---
title: "GSE183973 DESeq2"
author: "Mikias HW"
date: "2024-03-15"
output: html_document
---
#***GSE183973*** analysis
## Bulk Seq :Characterization of two lung alveolar macrophages in bronchoalveolar lavage fluid (BALF) cells in non-smoker healthy, smoker and COPD patients

### Load libraries
```{r results='hide', message=FALSE, warning=FALSE}
# library(GEOquery) # import datasets from GEO (unused)
library(tidyverse) # data wrangling & visualization
library(DESeq2) # Diverential gene expression analysis
library(vsn) # Transformation
library(apeglm) # log fold shrinking (adaptive t prior shrinkage estimator)
library(ashr) # log fold shrinking (adaptive shrinkage estimator)
library(pheatmap) # heatmaps
library(RColorBrewer) # Color themes
library(EnhancedVolcano) # Pleasing volcano plots
library(gridExtra) # GGplot extention
# library(GO.db) # Gene ontology
# library(GOstats) # Gene ontology
# library(clusterProfiler) # over representation/gene enrichment
```


***Note:*** Using GEOquery will require some troubleshooting as the GSE submission for this dataset lacked feature information. Instead the CSV files for gene counts and metadata can be download directly from [GEO](https://www.ncbi.nlm.nih.gov/geo/) and saved locally.

# Load data
```{r}
# Load CSV's for gene counts & metadata. Retain untidy names for ease
counts <- read.csv("Data/GSE183973_bulkRNA_gene_counts.csv",
  check.names = FALSE
)

metadata <- read.csv("Data/GSE183973_metadata_samples.csv",
  check.names = FALSE
)

# Set conditions variables as factors
metadata$patient_group <- factor(metadata$patient_group)

metadata$cell_type <- factor(metadata$cell_type)

# Define missing column names
colnames(counts)[1] <- "genes"

row.names(counts) <- counts$genes

head(counts)

colnames(metadata)[1] <- "samples"

head(metadata)
```


# Match samples
```{r}
# Remove genes column (gene names retained as index)
# Assign to new df to retain genes column for later data exploration
geneCounts <- counts |>
  select(-genes)

# Match counts column names and metadata row names
desired_order <- metadata$samples

geneCounts <- geneCounts[, desired_order]

# Confirm match
all(colnames(geneCounts) %in% metadata$samples)

all(colnames(geneCounts) == metadata$samples)
```


# Construct DESeqDataSet object
```{r}
# Define design matrix for DESeq2
dds <- DESeqDataSetFromMatrix(
  countData = geneCounts,
  colData = metadata,
  design = ~ cell_type + patient_group
)

# normalization by estimating size factor
dds <- estimateSizeFactors(dds)

# remove low expressed genes
keep <- rowSums(counts(dds)) >= 10

dds <- dds[keep, ]

# set factor level (reference group) : Im interested in comparing copd and smokers to the reference group non-smokers in this case.
dds$patient_group <- relevel(dds$patient_group, ref = "non_smoker")

# Run DEG analysis
dds <- DESeq(dds)

dds

# lists the contracts
resultsNames(dds)
```


# View results of DEG analysis
```{r}
# defaul results with padj = 0.1
res <- results(dds)

# Specifying a strict FDR (p-adj) cutoff for posterity. (default is 0.1)
res05 <- results(dds, alpha = 0.05)

# Default contrast will be "smoker" vs reference group "non_smoker"
res05

summary(res05)

# Count of DEG's
sum(res$padj < 0.1, na.rm = TRUE)

sum(res05$padj < 0.05, na.rm = TRUE)
```


# Viewing DEG's alternate contracts
```{r}
# Next im curious about seeing the remaining group comparisons

# COPD vs Non-Smoker
resCOPD <- results(dds, alpha = 0.05, contrast = c("patient_group", "copd", "non_smoker"))

resCOPD

summary(resCOPD)

sum(resCOPD$padj < 0.05, na.rm = TRUE)

# COPD vs Smoker
resWild <- results(dds, alpha = 0.05, contrast = c("patient_group", "copd", "smoker"))

resWild

summary(resWild)

sum(resWild$padj < 0.05, na.rm = TRUE)
```


# Log fold Skrinking a chosen contrast (default contrast in this case)
Aids in visualization and gene ranking
```{r}
# Adaptive t prior shrinkage estimator
resLFC <- lfcShrink(dds,
  coef = "patient_group_smoker_vs_non_smoker",
  type = "apeglm"
)

# Original DESeq2 shrinkage estimator, an adaptive Normal distribution as prior.
resNorm <- lfcShrink(dds,
  coef = "patient_group_smoker_vs_non_smoker",
  type = "normal"
)

# Adaptive shrinkage estimator. Fits a mixture of Normal distributions to form the prior
resAsh <- lfcShrink(dds,
  coef = "patient_group_smoker_vs_non_smoker",
  type = "ashr"
)
```


***MA plot*** visualizes relationships between log ratio & mean values of two variables:
	• 	“M” = minus in the log scale. Log ratios on (y) axis.
	• 	“A” = average in the log scale. The mean values on (x) axis. 


# Define function to visualize MA plots
```{r}
plotMA_arrange_iterative <- function(res_list) {
  plots <- list()

  for (i in seq_along(res_list)) {
    res <- res_list[[i]]
    res_name <- names(res_list)[i] # Get the name of the res object
    p <- plotMA(res, returnData = TRUE) # DESeq2's PlotMA function
    p_plot <- ggplot(p, aes(x = mean, y = lfc, color = isDE)) +
      geom_point(aes(alpha = ifelse(isDE == "TRUE", 1, 0.1)), show.legend = FALSE) + # Reduce non DEG genes transperancy
      scale_x_continuous(trans = "log10") + # Scale mean counts
      ylim(-2, 2) +
      labs(title = res_name) # Use the name in the plot title

    plots[[i]] <- p_plot
  }

  do.call(grid.arrange, c(plots, nrow = 2))
}
```


# Visualize Log Fold Shrunken MA Plots
```{r}
# Plot log fold shrunken DEG's
res_list <- list(
  "apeglm" = resLFC,
  "normal" = resNorm,
  "ashr" = resAsh
)

plotMA_arrange_iterative(res_list)
```

# Visualize DEG results
```{r}
# Visualize log2 fold changes of a given variable over the mean of normalized counts for all samples

res_list <- list(
  "padj=0.1" = res,
  "padj=0.05" = res05,
  "Log fold shrunk padj=0.1" = resLFC
)

plotMA_arrange_iterative(res_list)
```


# Visualizing alternate contrasts
```{r}
res_list <- list(
  "Smoker vs Non_Smoker DEG's" = res,
  "COPD v Non Smoker DEG's" = resCOPD,
  "COPD v Smoker DEG's" = resWild
)

plotMA_arrange_iterative(res_list)
```

**Note**: If there is unwanted variation present in the data (e.g. batch effects) it is always recommend to correct for this, which can be accommodated in DESeq2 by including in the design any known batch variables or by using functions/packages such as svaseq in sva (Leek 2014) or the RUV functions in RUVSeq (Risso et al. 2014) to estimate variables that capture the unwanted variation. In addition, the ashr developers have a specific method for accounting for unwanted variation in combination with ashr (Gerard and Stephens 2017).

# Compare transformations and impact on data variance 
```{r}
# Variance stabilizing transformation. (log2 scaling for large counts)
vsd <- vst(dds, blind = FALSE)

rld <- rlog(dds, blind = FALSE)

ntd <- normTransform(dds)


meanSdPlot(assay(ntd))

meanSdPlot(assay(vsd))

meanSdPlot(assay(rld))
```


# Quality assesment with Heatmaps
```{r}
select <- order(rowMeans(counts(dds, normalized = TRUE)),
  decreasing = TRUE
)[1:20]

df <- as.data.frame(colData(dds)[, c("patient_group", "cell_type")])

pheatmap(assay(ntd)[select, ],
  cluster_rows = FALSE, show_rownames = FALSE,
  cluster_cols = FALSE, annotation_col = df
)

pheatmap(assay(vsd)[select, ],
  cluster_rows = FALSE, show_rownames = FALSE,
  cluster_cols = FALSE, annotation_col = df
)

pheatmap(assay(rld)[select, ],
  cluster_rows = FALSE, show_rownames = FALSE,
  cluster_cols = FALSE, annotation_col = df
)
```


```{r}
#
sampleDists <- dist(t(assay(vsd)))

sampleDistMatrix <- as.matrix(sampleDists)

rownames(sampleDistMatrix) <- paste(vsd$cell_type, vsd$patient_group, sep = "-")

colnames(sampleDistMatrix) <- NULL

colors <- colorRampPalette(rev(brewer.pal(9, "Blues")))(255)

pheatmap(sampleDistMatrix,
  clustering_distance_rows = sampleDists,
  clustering_distance_cols = sampleDists,
  col = colors
)
```


# PCA plots
```{r}
plotPCA(vsd, intgroup = c("cell_type", "patient_group"))

plotPCA(vsd, intgroup = c("cell_type"))


pcaData <- plotPCA(vsd,
  intgroup = c("cell_type", "patient_group"),
  returnData = TRUE
)

percentVar <- round(100 * attr(pcaData, "percentVar"))

ggplot(pcaData, aes(PC1, PC2, color = patient_group, shape = cell_type)) +
  geom_point(size = 3) +
  xlab(paste0("PC1: ", percentVar[1], "% variance")) +
  ylab(paste0("PC2: ", percentVar[2], "% variance")) +
  coord_fixed()
```


# Plot Counts
```{r}
# Plot the gene with the smallest p adj value across specified groupings
c1 <- plotCounts(dds, gene = which.min(res$padj), intgroup = c("cell_type"), returnData = TRUE)

c1_plot <- ggplot(c1, aes(x = cell_type, y = count)) +
  geom_point(position = position_jitter(w = 0.1, h = 0)) +
  scale_y_log10(breaks = c(25, 100, 400))

c2 <- plotCounts(dds, gene = which.min(res$padj), intgroup = c("patient_group"), returnData = TRUE)

c2_plot <- ggplot(c2, aes(x = patient_group, y = count)) +
  geom_point(position = position_jitter(w = 0.1, h = 0)) +
  scale_y_log10(breaks = c(25, 100, 400))

c3 <- plotCounts(dds, gene = which.min(res$padj), intgroup = c("cell_type", "patient_group"), returnData = TRUE)

c3_plot <- ggplot(c3, aes(x = patient_group, y = count, color = cell_type)) +
  geom_point(position = position_jitter(w = 0.1, h = 0)) +
  scale_y_log10(breaks = c(25, 100, 400))

gridExtra::grid.arrange(c1_plot, c2_plot, c3_plot, nrow = 2)
```


# Merge counts & Metadata for Data exploration
```{r}
# Pivot DF for exploratory data analysis
countsLong <- counts |>
  pivot_longer(cols = !genes, names_to = "samples", values_to = "counts")

head(countsLong)

# Annotate counts with metadata
counts <- countsLong |>
  left_join(metadata, by = c("samples" = "samples"))

head(counts)
```


# Exploratory data analysis (with randomly selected genes, for now)
```{r eval=FALSE}
# barplot
counts |>
  filter(genes == "CD101") |>
  ggplot(aes(x = samples, y = counts, fill = cell_type)) +
  geom_col() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# density plot
counts |>
  filter(genes == "FTL") |>
  ggplot(aes(x = counts, fill = cell_type)) +
  geom_density(alpha = 0.5)

# boxplot
counts |>
  filter(genes == "LYZ") |>
  ggplot(aes(x = cell_type, y = counts)) +
  geom_boxplot()

# voilinplot
counts |>
  filter(genes == "CD74") |>
  ggplot(aes(x = cell_type, y = counts)) +
  geom_violin()

# scatterplot
counts |>
  filter(genes == "FTL" | genes == "LYZ") |>
  pivot_wider(names_from = genes, values_from = counts) |>
  ggplot(aes(x = FTL, y = LYZ, color = cell_type)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE)

# heatmap
genesOfInterest <- c("FTL", "FN1", "CD74", "LYZ")

counts |>
  filter(genes %in% genesOfInterest) |>
  ggplot(aes(x = samples, y = genes, fill = counts)) +
  geom_tile() +
  scale_fill_gradient(low = "white", high = "red") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


### Plot DE genes results
```{r}
plotMA(res)


EnhancedVolcano(res,
  lab = rownames(res),
  x = "log2FoldChange",
  y = "pvalue",
  title = "Smoker vs Non-smoker",
  pCutoff = 1e-05,
  FCcutoff = 0.5,
  pointSize = 2,
  labSize = 6.0,
  colAlpha = 0.3
)



# plot chosen genes per chosen conditions
plotCounts(dds, gene = which.min(res$padj), intgroup = "patient_group")

plotCounts(dds, gene = which.min(res$padj), intgroup = c("patient_group", "cell_type"))

plotCounts(dds, gene = "CD101", intgroup = "patient_group")

p <- plotCounts(dds,
  gene = which.min(res$padj),
  intgroup = c("patient_group", "cell_type"),
  returnData = TRUE
)

ggplot(p, aes(x = patient_group, y = count, color = cell_type)) +
  geom_point(position = position_jitter(w = 0.1, h = 0), size = 3) +
  scale_y_log10(breaks = c(25, 100, 400))
```


### Subset results
```{r}
# Extract differentially expressed genes
DE_genes <- subset(res, padj < 0.05)

summary(DE_genes)

DEG <- DE_genes@rownames
```


### Plot subset results
```{r}
plotMA(DE_genes)

counts |>
  filter(genes %in% DEG) |>
  ggplot(aes(x = samples, y = genes, fill = counts)) +
  geom_tile() +
  scale_fill_gradient(low = "white", high = "red") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


# Exporting results
```{r}
# order results by pvalue
resOrdered <- res[order(res$pvalue), ]

resOrdered

summary(resOrdered)

resOrdered05 <- subset(resOrdered, padj < 0.05)
resOrdered05

# write.csv(as.data.frame(resOrdered05), file="Smoker_NonSmoker_results_padj05.csv")
```

### Enrichment/Over-representation analysis (Incomplete)
https://yulab-smu.top/biomedical-knowledge-mining-book/index.html

Gene Ontology requires list of genes counts
Gene set enrichment requires normalized counts

Packages to test:
clusterProfiler
ChIPseeker
DOSE
enrichplot
GOSemSim
meshes
ReactomePA




### Session Info
```{r}
sessionInfo()
```
