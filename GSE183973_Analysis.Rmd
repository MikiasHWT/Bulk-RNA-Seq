---
title: "GSE183973 DESeq2"
author: "Mikias HW"
date: "2024-03-15"
output: 
  prettydoc::html_pretty:
    theme: hpstr
    toc: yes
    df_print: paged
---

***Work in progress*** 
(https://github.com/MikiasHWT/Bulk-RNA-Seq)

Purpose : Comparison of RNA expression of three innate immune cell populations across three patient groups. 

Load libraries
```{r results='hide', message=FALSE, warning=FALSE}
library(prettydoc)
# library(GEOquery) # import datasets from GEO (unused)
library(DESeq2) # Diverential gene expression analysis
library(vsn) # Transformation
library(apeglm) # log fold shrinking (adaptive t prior shrinkage estimator)
library(ashr) # log fold shrinking (adaptive shrinkage estimator)
library(pheatmap) # heatmaps
library(RColorBrewer) # Color themes
library(EnhancedVolcano) # Pleasing volcano plots
library(gridExtra) # GGplot extention
library(DT) # nice data tables
library(SparseArray)
library(ggvenn)
library(qvalue)

library(org.Mm.eg.db) # Mouse database
library(org.Hs.eg.db) # Human database
library(DOSE)
library(pathview)
library(clusterProfiler) # over representation/gene enrichment
library(AnnotationHub)
library(ensembldb)
library(enrichplot)
library(biomaRt)
# library(GO.db) # Gene ontology
# library(GOstats) # Gene ontology
library(tidyverse) # data wrangling & visualization
library(conflicted)
```

Conflicted functions
```{r results='hide', message=FALSE, warning=FALSE}
# Set function preferences
conflicts_prefer(dplyr::select)

conflicts_prefer(dplyr::filter)

conflicts_prefer(SparseArray::rowSds)

```

Define MA Plotting function
**MA plot** visualizes relationships between log ratio & mean values of two variables:
	• 	“M” = minus in the log scale. Log ratios on (y) axis.
	• 	“A” = average in the log scale. The mean values on (x) axis.
```{r}
# MA Plots
# Arranged into 2 rows
# Color & translucency by DEG
# Plot titles fed in as arguments
# Mean counts (x-axis) Log10 transformed

plotMA_arrange_iterative <- function(res_list) {
  plots <- list()

  for (i in seq_along(res_list)) {
    res <- res_list[[i]]
    res_name <- names(res_list)[i] # Get the name of the res object
    p <- plotMA(res, returnData = TRUE) # DESeq2's PlotMA function
    p_plot <- ggplot(p, aes(x = mean, y = lfc, color = isDE)) +
      geom_point(aes(alpha = ifelse(isDE == "TRUE", 1, 0.1)), show.legend = FALSE) + # Reduce non DEG genes transperancy
      scale_x_continuous(trans = "log10") + # Scale mean counts
      ylim(-2, 2) +
      labs(title = res_name) # Use the name in the plot title

    plots[[i]] <- p_plot
  }

  do.call(grid.arrange, c(plots, nrow = 2))
}
```



Define Heatmap plotting function
```{r}
```

# Preparation  
***Note:*** Using GEOquery will require some troubleshooting as the GSE submission for this dataset lacked feature information. Instead the CSV files for gene counts and metadata can be download directly from [GEO](https://www.ncbi.nlm.nih.gov/geo/) and saved locally.

## Load data
```{r}
# Load CSV's for gene counts & metadata. Retain untidy names for ease
counts <- read.csv("Data/GSE183973_bulkRNA_gene_counts.csv",
  check.names = FALSE
)

metadata <- read.csv("Data/GSE183973_metadata_samples.csv",
  check.names = FALSE
)

head(counts)

head(metadata)
```

Initially, Two sets of variables are considered for this analysis.  

Cell types: `r unique(metadata$cell_type)`

Patient Groups: `r unique(metadata$patient_group)`

There are `r length(unique(metadata$patient_initials))` patients evenly spread across the `r length(unique(metadata$patient_group))` groups. Each patient contributing Blood Monocytes (`r unique(metadata$cell_type[1])`), Alveolar Macrophages (`r unique(metadata$cell_type[2])`), and Regulatory Macrophages (`r unique(metadata$cell_type[3])`), the latter two being extracted from bronchoalveolar lavage fluid. Cells were isolated by Flow Cytometry and sequenced in Bulk. 


## Clean up 
```{r}
# Set conditions variables as factors
metadata$patient_group <- factor(metadata$patient_group)

metadata$cell_type <- factor(metadata$cell_type)

# Define missing column names
colnames(counts)[1] <- "genes"

row.names(counts) <- counts$genes

colnames(metadata)[1] <- "samples"
```


## Match samples
```{r}
# Remove genes column (gene names retained as index)
# Assign to new df to retain genes column for later data exploration
geneCounts <- counts |>
  select(-genes)

# Match counts column names and metadata row names
desired_order <- metadata$samples

geneCounts <- geneCounts[, desired_order]

# Confirm match
all(colnames(geneCounts) %in% metadata$samples)

all(colnames(geneCounts) == metadata$samples)
```


## Construct DESeqDataSet object
```{r}
# Define design matrix for DESeq2
dds <- DESeqDataSetFromMatrix(
  countData = geneCounts,
  colData = metadata,
  design = ~ cell_type + patient_group
)

# normalization by estimating size factor
dds <- estimateSizeFactors(dds)

# remove low expressed genes
keep <- rowSums(counts(dds)) >= 10

dds <- dds[keep, ]

# set factor level (reference group) : Im interested in comparing copd and smokers to the reference group non-smokers in this case.
dds$patient_group <- relevel(dds$patient_group, ref = "non_smoker")

# Run DEG analysis
dds <- DESeq(dds)

dds

# lists the contracts
resultsNames(dds)
```


# Results
**Note** U-shaped p-value histograms-can indicate that a one-sided test was performed on data where there is signal in both directions, or it can indicate that there is dependence among the variables in the data.

Might be worth checking `cell_type:patient_group` interaction term. As Pvalue histogram has a little Ushape to it. 

## View results of default DEG analysis
```{r}
# defaul results with padj = 0.1
res <- results(dds)

# Specifying a strict FDR (p-adj) cutoff for posterity. (default is 0.1)
res05 <- results(dds, alpha = 0.05)

# Default contrast will be "smoker" vs reference group "non_smoker"
head(as.data.frame(res05))

summary(res05)

# Count of DEG's & display pvalue histograms
sum(res$padj < 0.1, na.rm = TRUE)

hist(res$pvalue)

# Set a more strict FDR cutoff
sum(res05$padj < 0.05, na.rm = TRUE)

hist(res05$pvalue)
```


## FDR estimations
```{r}
qobj <- qvalue(res$pvalue)

summary(qobj)

hist(qobj)

plot(qobj)
```


## Test interaction term
```{r} 
# dds2 <- DESeqDataSetFromMatrix(
#   countData = geneCounts,
#   colData = metadata,
#   design = ~ cell_type + patient_group + cell_type:patient_group
# )
#
# dds2 <- estimateSizeFactors(dds2)
#
# keep <- rowSums(counts(dds2)) >= 10
#
# dds2 <- dds2[keep, ]
#
# dds2$patient_group <- relevel(dds2$patient_group, ref = "non_smoker")
#
# dds2 <- DESeq(dds2)
#
# resultsNames(dds2)
#
# res105 <- results(dds2, alpha = 0.1)
#
# summary(res105)
#
# sum(res105$padj < 0.1, na.rm = TRUE)
#
# hist(res105$pvalue)
#
# qobj2 <- qvalue(res105$pvalue)
#
# summary(qobj2)
#
# hist(qobj2)
#
# plot(qobj2)
```


## Viewing DEG's alternate contracts
```{r}
# Next im curious about seeing the remaining group comparisons

# COPD vs Non-Smoker
resCOPD <- results(dds, alpha = 0.05, contrast = c("patient_group", "copd", "non_smoker"))

head(as.data.frame(resCOPD))

summary(resCOPD)

sum(resCOPD$padj < 0.05, na.rm = TRUE)

hist(resCOPD$pvalue)

qobj <- qvalue(resCOPD$pvalue)

summary(qobj)

hist(qobj)

plot(qobj)

# COPD vs Smoker
resWild <- results(dds, alpha = 0.05, contrast = c("patient_group", "copd", "smoker"))

head(as.data.frame(resWild))

summary(resWild)

sum(resWild$padj < 0.05, na.rm = TRUE)

hist(resWild$pvalue)

qobj <- qvalue(resWild$pvalue)

summary(qobj)

hist(qobj)

plot(qobj)
```


## Log fold Skrink DEG's
Aids in visualization and gene ranking
```{r}
# Adaptive t prior shrinkage estimator
resLFC <- lfcShrink(dds,
  coef = "patient_group_smoker_vs_non_smoker",
  type = "apeglm"
)

# Original DESeq2 shrinkage estimator, an adaptive Normal distribution as prior.
resNorm <- lfcShrink(dds,
  coef = "patient_group_smoker_vs_non_smoker",
  type = "normal"
)

# Adaptive shrinkage estimator. Fits a mixture of Normal distributions to form the prior
resAsh <- lfcShrink(dds,
  coef = "patient_group_smoker_vs_non_smoker",
  type = "ashr"
)
```


## Subset results
```{r}
# Extract differentially expressed genes
subRes05 <- subset(res, padj < 0.05)

subRes01 <- subset(res, padj < 0.01)

subRes005 <- subset(res, padj < 0.005)

# DEG05 <- subRes05@rownames
#
# DEG01 <- subRes01@rownames
#
# DEG005 <- subRes005@rownames
```


### Plot subset results
```{r}
# counts |>
#   filter(genes %in% DEG) |>
#   ggplot(aes(x = samples, y = genes, fill = counts)) +
#   geom_tile() +
#   scale_fill_gradient(low = "white", high = "red") +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


# Visualize
## Visualize DEG results
```{r}
# Visualize log2 fold changes of a given variable over the mean of normalized counts for all samples

res_list <- list(
  "padj=0.1" = res,
  "padj=0.05" = res05,
  "Log fold shrunk padj=0.1" = resLFC
)

plotMA_arrange_iterative(res_list)
```


## Visualizing alternate contrasts
```{r}
res_list <- list(
  "Smoker vs Non_Smoker DEG's" = res,
  "COPD v Non Smoker DEG's" = resCOPD,
  "COPD v Smoker DEG's" = resWild
)

plotMA_arrange_iterative(res_list)
```


## Visualize Log Fold Shrunken MA Plots
```{r}
# Plot log fold shrunken DEG's
res_list <- list(
  "apeglm" = resLFC,
  "normal" = resNorm,
  "ashr" = resAsh
)

plotMA_arrange_iterative(res_list)
```

## visualize subset results
```{r}
# Plot log fold shrunken DEG's
res_list <- list(
  "Subset 0.05" = subRes05,
  "Subset 0.01" = subRes01,
  "Subset 0.005" = subRes005
)

plotMA_arrange_iterative(res_list)
```

**Note**: If there is unwanted variation present in the data (e.g. batch effects) it is always recommend to correct for this, which can be accommodated in DESeq2 by including in the design any known batch variables or by using functions/packages such as svaseq in sva (Leek 2014) or the RUV functions in RUVSeq (Risso et al. 2014) to estimate variables that capture the unwanted variation. In addition, the ashr developers have a specific method for accounting for unwanted variation in combination with ashr (Gerard and Stephens 2017).


# Transform

## Raw gene variance 
Raw RNA sequencing counts have a high degree of variability; which increases with a genes average expression level. This variability needs to be accounted before some downstream analysis such as visualization and clustering. We do this by transforming the data such that the variance is stabilized across the entire spectrum of expression values, allowing for use of statistical models/methods where that is a requirement. 

```{r}
# Filter out low expressed genes
keep <- rowSums(geneCounts) > 10

filtCounts <- as.matrix(geneCounts[keep, ])

# Visualize gene expression values by sample
boxplot(filtCounts, main = "Raw counts", ylab = "Gene Expression", las = 2)

# Mean expression vs standard deviation (SD)
plot(rowMeans(filtCounts), rowSds(filtCounts),
  main = "Raw counts: Mean vs SD",
  xlim = c(0, 10000),
  ylim = c(0, 5000)
)

# Save as ggplot
Raw <- ggplot(filtCounts, aes(
  x = rowMeans(filtCounts),
  y = rowSds(filtCounts)
)) +
  geom_point() +
  geom_smooth() +
  labs(title = "Raw", x = "Mean", y = "SD")
```


## Various Transformations

Log2 fold transformation were the standard in the past, but they can result in over representation of low expressed genes. As such various other methods are implemented. The goal is that the standard deviation stays consistent across all mean values of gene expression. vst and rlog have pros and cons determined by the number of samples. 

```{r}
# Get log2 counts
logcounts <- log2(filtCounts + 1)

# Plot mean vs SD
Log2 <- ggplot(logcounts, aes(
  x = rowMeans(logcounts),
  y = rowSds(logcounts)
)) +
  geom_point() +
  geom_smooth() +
  labs(title = "Log2", x = "Mean", y = "SD")

# Variance stabilizing transformation
vst_counts <- vst(filtCounts)

# Plot
VST <- ggplot(vst_counts, aes(
  x = rowMeans(vst_counts),
  y = rowSds(vst_counts)
)) +
  geom_point() +
  geom_smooth() +
  labs(title = "VST", x = "Mean", y = "SD")

# Rlog counts
rlog_counts <- rlog(filtCounts)

# Plot
Rlog <- ggplot(rlog_counts, aes(
  x = rowMeans(rlog_counts),
  y = rowSds(rlog_counts)
)) +
  geom_point() +
  geom_smooth() +
  labs(title = "Rlog", x = "Mean", y = "SD")

# Arrange Plots
grid.arrange(Raw, Log2, VST, Rlog, nrow = 2)
```

```{r}
# select <- order(rowMeans(rlog_counts), decreasing = TRUE)[1:20]
#
# df <- as.data.frame(metadata[, c("patient_group", "cell_type")])
#
# pheatmap(rlog_counts[select,], main = "rlog",
#          cluster_rows = TRUE, show_rownames = TRUE,
#          cluster_cols = TRUE, show_colnames = FALSE)
```



```{r}
# Variance stabilizing transformation. (log2 scaling for large counts)
vsd <- vst(dds, blind = FALSE)

rld <- rlog(dds, blind = FALSE)

ntd <- normTransform(dds)


#
# meanSdPlot(assay(ntd))
#
# meanSdPlot(assay(vsd))
#
# meanSdPlot(assay(rld))
```

# Quality Assesment

## Quality assesment with Heatmaps
```{r}
select <- order(rowMeans(counts(dds, normalized = TRUE)),
  decreasing = TRUE
)[1:20]

df <- as.data.frame(colData(dds)[, c("patient_group", "cell_type")])

pheatmap(assay(ntd)[select, ],
  cluster_rows = TRUE, show_rownames = TRUE,
  cluster_cols = TRUE, annotation_col = df, show_colnames = FALSE,
  main = "ntd", scale = "row"
)

pheatmap(assay(vsd)[select, ],
  cluster_rows = TRUE, show_rownames = TRUE,
  cluster_cols = TRUE, annotation_col = df, show_colnames = FALSE,
  main = "vsd", scale = "row"
)

pheatmap(assay(rld)[select, ],
  cluster_rows = TRUE, show_rownames = TRUE,
  cluster_cols = TRUE, annotation_col = df, show_colnames = FALSE,
  main = "rld", scale = "row"
)
```

## Sample distance
```{r}
# Determine between group variety
sampleDists <- dist(t(assay(vsd)))

sampleDistMatrix <- as.matrix(sampleDists)

rownames(sampleDistMatrix) <- paste(vsd$cell_type, vsd$patient_group, sep = "-")

colnames(sampleDistMatrix) <- NULL

colors <- colorRampPalette(rev(brewer.pal(9, "Blues")))(255)

pheatmap(sampleDistMatrix,
  clustering_distance_rows = sampleDists,
  clustering_distance_cols = sampleDists,
  col = colors
)
```

## PCA plots
```{r}
plotPCA(vsd, intgroup = c("cell_type", "patient_group"))

plotPCA(vsd, intgroup = c("cell_type"))


pcaData <- plotPCA(vsd,
  intgroup = c("cell_type", "patient_group"),
  returnData = TRUE
)

percentVar <- round(100 * attr(pcaData, "percentVar"))

ggplot(pcaData, aes(PC1, PC2, color = patient_group, shape = cell_type)) +
  geom_point(size = 3) +
  xlab(paste0("PC1: ", percentVar[1], "% variance")) +
  ylab(paste0("PC2: ", percentVar[2], "% variance")) +
  coord_fixed()
```


## Plot Counts
```{r}
# Plot the gene with the smallest p adj value across specified groupings
c1 <- plotCounts(dds, gene = which.min(res$padj), intgroup = c("cell_type"), returnData = TRUE)

c1_plot <- ggplot(c1, aes(x = cell_type, y = count)) +
  geom_point(position = position_jitter(w = 0.1, h = 0)) +
  scale_y_log10(breaks = c(25, 100, 400))

c2 <- plotCounts(dds, gene = which.min(res$padj), intgroup = c("patient_group"), returnData = TRUE)

c2_plot <- ggplot(c2, aes(x = patient_group, y = count)) +
  geom_point(position = position_jitter(w = 0.1, h = 0)) +
  scale_y_log10(breaks = c(25, 100, 400))

c3 <- plotCounts(dds, gene = which.min(res$padj), intgroup = c("cell_type", "patient_group"), returnData = TRUE)

c3_plot <- ggplot(c3, aes(x = patient_group, y = count, color = cell_type)) +
  geom_point(position = position_jitter(w = 0.1, h = 0)) +
  scale_y_log10(breaks = c(25, 100, 400))

gridExtra::grid.arrange(c1_plot, c2_plot, c3_plot, nrow = 2)

# plot chosen genes per chosen conditions
plotCounts(dds, gene = which.min(res$padj), intgroup = "patient_group")

plotCounts(dds, gene = which.min(res$padj), intgroup = c("patient_group", "cell_type"))

plotCounts(dds, gene = "CD101", intgroup = "patient_group")

p <- plotCounts(dds,
  gene = which.min(res$padj),
  intgroup = c("patient_group", "cell_type"),
  returnData = TRUE
)

ggplot(p, aes(x = patient_group, y = count, color = cell_type)) +
  geom_point(position = position_jitter(w = 0.1, h = 0), size = 3) +
  scale_y_log10(breaks = c(25, 100, 400))
```

# Exploratory Data Analysis

## Merge counts & Metadata for Data exploration
```{r}
# Pivot DF for exploratory data analysis
countsLong <- counts |>
  pivot_longer(cols = !genes, names_to = "samples", values_to = "counts")

head(countsLong)

# Annotate counts with metadata
counts <- countsLong |>
  left_join(metadata, by = c("samples" = "samples"))

head(counts)
```


## Random EDA
```{r}
# barplot
counts |>
  filter(genes == "CD101") |>
  ggplot(aes(x = samples, y = counts, fill = cell_type)) +
  geom_col() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# density plot
counts |>
  filter(genes == "FTL") |>
  ggplot(aes(x = counts, fill = cell_type)) +
  geom_density(alpha = 0.5)

# boxplot
counts |>
  filter(genes == "LYZ") |>
  ggplot(aes(x = cell_type, y = counts)) +
  geom_boxplot()

# voilinplot
counts |>
  filter(genes == "CD74") |>
  ggplot(aes(x = cell_type, y = counts)) +
  geom_violin()

# scatterplot
counts |>
  filter(genes == "FTL" | genes == "LYZ") |>
  pivot_wider(names_from = genes, values_from = counts) |>
  ggplot(aes(x = FTL, y = LYZ, color = cell_type)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE)

# heatmap
genesOfInterest <- c("FTL", "FN1", "CD74", "LYZ")

counts |>
  filter(genes %in% genesOfInterest) |>
  ggplot(aes(x = samples, y = genes, fill = counts)) +
  geom_tile() +
  scale_fill_gradient(low = "white", high = "red") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


## Volcano Plot
```{r}
EnhancedVolcano(res,
  lab = rownames(res),
  x = "log2FoldChange",
  y = "pvalue",
  title = "Smoker vs Non-smoker",
  pCutoff = 1e-05,
  FCcutoff = 0.5,
  pointSize = 2,
  labSize = 6.0,
  colAlpha = 0.3
)

resLFC_DF <- as.data.frame(resLFC) %>%
  rownames_to_column("GeneID")

resLFC_DF <- resLFC_DF %>%
  mutate(`-log10(pvalue)` = -log10(pvalue))

ggplot(resLFC_DF, aes(x = log2FoldChange, y = `-log10(pvalue)`)) +
  geom_point(aes(colour = padj < 0.05), size = 1) +
  geom_text(data = ~ top_n(.x, 5, wt = -padj), aes(label = GeneID)) +
  labs(title = "Smoker vs NonSmoker")
```


### Subset results
```{r}
# Extract differentially expressed genes
DE_genes <- subset(res, padj < 0.05)

summary(DE_genes)

DEG <- DE_genes@rownames
```


### Plot subset results
```{r}
plotMA(DE_genes)

counts |>
  filter(genes %in% DEG) |>
  ggplot(aes(x = samples, y = genes, fill = counts)) +
  geom_tile() +
  scale_fill_gradient(low = "white", high = "red") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


# Exporting results
```{r}
# order results by pvalue
resOrdered <- res[order(res$pvalue), ]

resOrdered

summary(resOrdered)

resOrdered05 <- subset(resOrdered, padj < 0.05)
resOrdered05

# write.csv(as.data.frame(resOrdered05), file="Smoker_NonSmoker_results_padj05.csv")
```

#Venn Diagram
```{r}
vennTest <- tibble(Geneid = rownames(res)) %>%
  mutate(NonSmokerVSSmoker = res$padj < 0.05 &
    !is.na(res$padj) &
    res$log2FoldChange > 0) %>%
  mutate(Smoker = res$padj < 0.05 &
    !is.na(res$padj) &
    res$log2FoldChange < 0) %>%
  mutate(NonSmokerVSCOPD = resCOPD$padj < 0.05 &
    !is.na(resCOPD$padj) &
    resCOPD$log2FoldChange > 0) %>%
  mutate(COPD = resCOPD$padj < 0.05 &
    !is.na(resCOPD$padj) &
    resCOPD$log2FoldChange < 0)

ggvenn(vennTest, set_name_size = 4)
```

# Next Analysis: Enrichment/Over-representation analysis 
https://yulab-smu.top/biomedical-knowledge-mining-book/index.html

file:///C:/Users/Owner/Downloads/RNASEQ20_Day3_HandsOn.pdf

```{r}
# Create background dataset for hypergeometric testing using all genes tested for significance in the results
all_genes <- as.character(rownames(res))

# Extract significant results
signif_res <- res[res$padj < 0.05 & !is.na(res$padj), ]

signif_genes <- as.character(rownames(signif_res))

# Run GO enrichment analysis
ego <- enrichGO(
  gene = signif_genes,
  universe = all_genes,
  keyType = "SYMBOL",
  OrgDb = org.Hs.eg.db,
  ont = "BP",
  pAdjustMethod = "BH",
  qvalueCutoff = 0.05,
  readable = TRUE
)
# Output results from GO analysis to a table
cluster_summary <- data.frame(ego)

# Visualize
dotplot(ego, showCategory = 50)

# # Plot enrichment map
# emapplot(ego, showCategory = 50)
# 
# # Calculate term similarity matrix
# sim_matrix <- pairwise_termsim(ego)
# 
# # Plot enrichment map
# emapplot(ego, showCategory = 50, sim_matrix = sim_matrix)

# To color genes by log2 fold changes
signif_res_lFC <- signif_res$log2FoldChange

cnetplot(ego,
  categorySize = "pvalue",
  showCategory = 5,
  foldChange = signif_res_lFC,
  vertex.label.font = 6
)
```


```{r}
# # Gene set enrichment analysis (GSEA) using clusterProfiler and Pathview
# mart <- useDataset("hsapiens_gene_ensembl", useMart("ensembl"))
# 
# mart <- useEnsembl(biomart = "ensembl", 
#                      dataset = "hsapiens_gene_ensembl")
# 
# genes <- getBM(
#   filters = "chromosome_name",
#   attributes = "ensembl_gene_id",
#   values = all_genes,
#   mart = mart
# )
# 
# 
# indNA <- which(is.na(genes$entrezgene_id))
# 
# genes_noNA <- genes[-indNA, ]
# 
# indnodup <- which(duplicated(genes_noNA$ entrezgene_id) == F)
# 
# genes_noNA_nodup <- genes_noNA[indnodup, ]
# 
# lFC <- res$log2FoldChange[-indNA]
# 
# lFC <- lFC[indnodup]
# 
# names(lFC) <- genes_noNA_nodup$entrezgene_id
# 
# # Sort fold changes in decreasing order
# lFC <- sort(lFC, decreasing = TRUE)
# 
# 
# # Perform the GSEA using KEGG gene sets:
# gseaKEGG <- gseKEGG(
#   geneList = lFC,
#   organism = "mmu",
#   nPerm = 1000, # default number permutations
#   minGSSize = 5, # minimum gene set size
#   pvalueCutoff = 0.1, # padj cutoff value
#   verbose = FALSE
# )
# 
# # Extract the GSEA results
# gseaKEGG_results <- gseaKEGG@result

```


Session Info
```{r}
sessionInfo()
```
